# **Vibe Coding Navigator - AI Development Rules**

## **Core Principles**

As an AI Development Assistant, my objective is to execute fully autonomous software development with zero human coding intervention, ensuring all generated code is controllable, reliable, and of high quality. I will strictly adhere to the following processes and standards.

## **1. Project Management & Tracking**

I will manage the project by maintaining the following documents, located within the `/docs` directory:

*   **`docs/PROGRESS.md`**: The central progress tracking file using a Markdown task list.
    *   **Format**:
        ```markdown
        # Project Progress
        ## Module Name
        - [ ] Target 1
        - [ ] Target 2 #in-progress
        - [x] Target 3
        ```
    *   **Responsibility**: Before starting any task, I must read this file to identify the next un-checked target. Upon completion, I must update the checkbox to `[x]`. I will mark the currently active task with an `#in-progress` tag.

*   **`docs/SYSTEM_DESIGN.md`**: The high-level system design document.
    *   **Content**: System architecture diagrams (generated using Mermaid), module breakdown and dependencies, technology stack, and core API contracts.
    *   **Timing**: Must be completed before any implementation begins.

*   **`docs/MODULE_[name]_DESIGN.md`**: The detailed design document for each module.
    *   **Content**: Detailed functional descriptions for each target, API definitions (inputs/outputs), data structures, and internal dependencies.
    *   **Timing**: Must be completed before the development of a module begins, primarily for human review.

*   **`docs/TEST_PLAN.md`**: The consolidated testing plan.
    *   **Content**: All unit and integration test cases for every target. Must explicitly state the coverage goal (e.g., â‰¥90%).

*   **`docs/INCIDENTS.md`**: A logbook for recording all automated healing events.
    *   **Content**: For every auto-fix, an entry detailing the problem, the root cause analysis, the applied solution, and the verification result.

## **2. Project Structure**

I will generate and maintain the project using the following standardized directory structure:

```
/
|-- docs/
|   |-- INCIDENTS.md
|   |-- MODULE_[name]_DESIGN.md
|   |-- PROGRESS.md
|   |-- SYSTEM_DESIGN.md
|   |-- TEST_PLAN.md
|-- src/
|   |-- module_a/
|   |   |-- __init__.py
|   |   |-- feature_x.py
|   |-- module_b/
|-- tests/
|   |-- test_module_a/
|   |   |-- test_feature_x.py
|-- .gitignore
|-- README.md
|-- requirements.txt   # Or package.json, etc.
|-- VIBE_RULES.md
```

*   **`/docs`**: Contains all project management, design, and incident-log documents.
*   **`/src`**: Contains all production source code, organized by feature modules.
*   **`/tests`**: Contains all test code, mirroring the `/src` directory structure.

## **3. Technology Stack & Configuration**

To ensure code quality and predictability, the following technology constraints are mandatory.

*   **Language Policy**: The project must be implemented exclusively in either **TypeScript** or **Python**. The chosen language must be used consistently throughout the project.

*   **TypeScript Configuration**:
    *   **Dependency Management**: Use `package.json` with `npm` or `yarn`. All dependencies must have explicitly versioned (e.g., `"react": "18.2.0"`) rather than version ranges (e.g., `"^18.2.0"`).
    *   **Compiler Options**: A `tsconfig.json` file must be present at the root. The `compilerOptions` **must** include `"strict": true` to enforce the strongest type-checking.
    *   **Linting & Formatting**: The project must be configured with ESLint (using `@typescript-eslint/parser`) and Prettier to maintain a consistent and high-quality codebase.

*   **Python Configuration**:
    *   **Dependency Management**: Use of `pyproject.toml` with a modern tool like **Poetry** or **PDM** is strongly preferred for managing dependencies and virtual environments. A `requirements.txt` generated by `pip-tools` is an acceptable alternative.
    *   **Installer**: **`uv`** should be used as the primary tool for installing packages and managing virtual environments.
    *   **Type Hinting**: All function definitions (parameters and return types) and variable declarations **must** include type hints as defined in PEP 484.
    *   **Static Type Checking**: **Mypy** must be used for static analysis. Its configuration (e.g., `mypy.ini` or `[tool.mypy]` in `pyproject.toml`) **must** be set to a strict level (e.g., including `disallow_untyped_defs = True`).
    *   **Linting & Formatting**: The project must be configured with **Black** for automated code formatting and a linter like **Ruff** or **Flake8**.

## **4. TDD (Test-Driven Development) Workflow**

I will strictly follow the TDD workflow for every target listed in `docs/PROGRESS.md`:

1.  **Select Target**: Choose an unchecked `[ ]` target from `docs/PROGRESS.md` and mark it with `#in-progress`.
2.  **Write Tests (Test-First)**:
    *   Write complete and isolated test cases for the selected target.
    *   **No-Mocking Policy**: All tests against external services (e.g., LLM APIs, databases, third-party APIs) **must use live, real connections**. Mocking or stubbing is strictly forbidden.
    *   Test code must be created before implementation code.
3.  **Run Tests (Red)**: Execute the tests and confirm they fail as expected because the feature is not yet implemented.
4.  **Write Code (Green)**: Write the minimum amount of code required to make the failing tests pass.
5.  **Refactor**: Improve the code's structure, readability, and performance without changing its external behavior (all tests must remain green).
6.  **Update Progress**: Remove the `#in-progress` tag and mark the target as complete `[x]` in `docs/PROGRESS.md`.
7.  **Integration Tests**: When a module's targets are complete, execute its integration tests.

## **5. Code Quality & Standards**

All code I generate must conform to these standards:

*   **Naming Conventions**: Descriptive names are mandatory. Adhere to language-specific conventions (e.g., `snake_case` for Python, `camelCase` for JavaScript/TypeScript).
*   **Type System**: Enforce static type checking (`mypy` for Python, `strict` mode for TypeScript).
*   **Documentation**: All functions and classes must have comprehensive docstrings/JSDoc, explaining their purpose, parameters, return values, and potential exceptions.
*   **Error Handling (Fail-Fast Protocol)**:
    *   **No Silent Fails**: Never suppress an error by using an empty `catch` block or returning a default value.
    *   **Propagate Exceptions**: All exceptions must be thrown upwards or wrapped in a more specific, high-level exception before being re-thrown.
    *   **Rich Context**: Exceptions must contain sufficient context to facilitate debugging.

## **6. AI-Native Architecture Principles**

The system architecture I design will follow these principles:

*   **High Cohesion, Loose Coupling**: Achieve modularity through clear interfaces and dependency injection.
*   **Self-Explanatory Code**: Prioritize readability and clarity through descriptive naming and type annotations, making the code itself the primary source of truth.
*   **Contract-Driven Development**: Define service interactions using formal specifications like OpenAPI/Swagger or JSON Schema.

## **7. Automated Healing Protocol**

When I encounter an error during execution or testing, I will initiate the following protocol:

1.  **Detect**: Identify the error or test failure.
2.  **Analyze**: Parse the full error message, stack trace, and relevant code.
3.  **Heal**: Isolate the root cause and patch the code.
4.  **Verify**: Re-run the relevant tests to confirm the fix is effective and has not introduced regressions.
5.  **Log**: Record the incident in `docs/INCIDENTS.md`, detailing the analysis and solution.

---
**This rule set is now active. I will follow these instructions for all development tasks.** 